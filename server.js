// Generated by CoffeeScript 1.10.0
(function() {
  var Encryptor, KEY, METHOD, PORT, ProtocolAuth, ServerInfo, config, configContent, configFile, configFromArgs, enableAuthSimple, fs, http, inetNtoa, k, net, options, parseArgs, path, server, timeout, v;

  net = require("net");

  fs = require("fs");

  path = require("path");

  http = require("http");

  parseArgs = require("minimist");

  Encryptor = require("./encrypt").Encryptor;

  ProtocolAuth = require("./ProtocolAuth").ProtocolAuth;

  ServerInfo = require('./ProtocolAuth').ServerInfo;

  options = {
    alias: {
      'r': 'remote_port',
      'k': 'password',
      'c': 'config_file',
      'm': 'method'
    },
    string: ['password', 'method', 'config_file'],
    "default": {
      'remote_port': process.env.PORT || 8080,
      'password': process.env.KEY,
      'method': process.env.METHOD,
      'config_file': path.resolve(__dirname, "config.json")
    }
  };

  inetNtoa = function(buf) {
    return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3];
  };

  configFromArgs = parseArgs(process.argv.slice(2), options);

  configFile = configFromArgs.config_file;

  configContent = fs.readFileSync(configFile);

  config = JSON.parse(configContent);

  for (k in configFromArgs) {
    v = configFromArgs[k];
    if (configFromArgs[k]) {
      config[k] = v;
    }
  }

  timeout = Math.floor(config.timeout * 1000);

  PORT = config.remote_port;

  KEY = config.password;

  METHOD = config.method;

  enableAuthSimple = process.env.AUTH_SIMPLE || false;

  if (config["auth_simple"]) {
    enableAuthSimple = config['auth_simple'];
  }

  server = http.createServer(function(req, res) {
    res.writeHead(200, {
      'Content-Type': 'text/plain'
    });
    return res.end('Good Day!');
  });

  server.obfs_data = (new ProtocolAuth()).initData();

  server.on('upgrade', function(req, connection, head) {
    var addrLen, cachedPieces, encryptor, headerLength, remote, remoteAddr, remotePort, server_info, stage;
    connection.write('HTTP/1.1 101 Web Socket Protocol Handshake\r\n' + 'Upgrade: WebSocket\r\n' + 'Connection: Upgrade\r\n' + '\r\n');
    console.log("server connected");
    server.getConnections(function(err, count) {
      console.log("concurrent connections:", count);
    });
    encryptor = new Encryptor(KEY, METHOD);
    stage = 0;
    headerLength = 0;
    remote = null;
    cachedPieces = [];
    addrLen = 0;
    remoteAddr = null;
    remotePort = null;
    connection.protocal_auth = new ProtocolAuth();
    server_info = new ServerInfo(server.obfs_data);
    connection.protocal_auth.setServerInfo(server_info);
    connection.on("data", function(data) {
      var addrtype, buf, e, error, error1;
      data = encryptor.decrypt(data);
      if (enableAuthSimple) {
        try {
          data = connection.protocal_auth.serverPostDecrypt(data);
        } catch (error) {
          e = error;
          console.log(e);
        }
      }
      if (stage === 5) {
        if (!remote.write(data)) {
          connection.pause();
        }
        return;
      }
      if (stage === 0) {
        try {
          addrtype = data[0];
          if (addrtype === 3) {
            addrLen = data[1];
          } else if (addrtype !== 1) {
            console.warn("unsupported addrtype: " + addrtype);
            connection.end();
            return;
          }
          if (addrtype === 1) {
            remoteAddr = inetNtoa(data.slice(1, 5));
            remotePort = data.readUInt16BE(5);
            headerLength = 7;
          } else {
            remoteAddr = data.slice(2, 2 + addrLen).toString("binary");
            remotePort = data.readUInt16BE(2 + addrLen);
            headerLength = 2 + addrLen + 2;
          }
          console.log(remoteAddr);
          remote = net.connect(remotePort, remoteAddr, function() {
            var i, piece;
            console.log("connecting", remoteAddr);
            i = 0;
            while (i < cachedPieces.length) {
              piece = cachedPieces[i];
              remote.write(piece);
              i++;
            }
            cachedPieces = null;
            return stage = 5;
          });
          remote.on("data", function(data) {
            var error1;
            if (enableAuthSimple) {
              try {
                data = connection.protocal_auth.serverPreEncrypt(data);
              } catch (error1) {
                e = error1;
                console.log(e);
              }
            }
            data = encryptor.encrypt(data);
            if (!connection.write(data)) {
              return remote.pause();
            }
          });
          remote.on("end", function() {
            console.log("remote disconnected");
            server.getConnections(function(err, count) {
              console.log("concurrent connections:", count);
            });
            return connection.end();
          });
          remote.on("error", function(e) {
            console.log("remote : " + e);
            connection.destroy();
            return server.getConnections(function(err, count) {
              console.log("concurrent connections:", count);
            });
          });
          remote.on("drain", function() {
            return connection.resume();
          });
          remote.setTimeout(timeout, function() {
            connection.end();
            return remote.destroy();
          });
          if (data.length > headerLength) {
            buf = new Buffer(data.length - headerLength);
            data.copy(buf, 0, headerLength);
            cachedPieces.push(buf);
            buf = null;
          }
          return stage = 4;
        } catch (error1) {
          e = error1;
          console.warn(e);
          connection.destroy();
          if (remote) {
            return remote.destroy();
          }
        }
      } else {
        if (stage === 4) {
          return cachedPieces.push(data);
        }
      }
    });
    connection.on("end", function() {
      console.log("server disconnected");
      if (remote) {
        remote.destroy();
      }
      return server.getConnections(function(err, count) {
        console.log("concurrent connections:", count);
      });
    });
    connection.on("error", function(e) {
      console.warn("server: " + e);
      if (remote) {
        remote.destroy();
      }
      return server.getConnections(function(err, count) {
        console.log("concurrent connections:", count);
      });
    });
    connection.on("drain", function() {
      if (remote) {
        return remote.resume();
      }
    });
    return connection.setTimeout(timeout, function() {
      if (remote) {
        remote.destroy();
      }
      return connection.destroy();
    });
  });

  server.listen(PORT, function() {
    var address;
    address = server.address();
    return console.log("server listening at", address);
  });

  server.on("error", function(e) {
    if (e.code === "EADDRINUSE") {
      console.warn("Address in use, aborting");
    }
    return process.exit(1);
  });

}).call(this);
